(* Copyright 2017-2019 Pierre Courtieu *)
(* Credits to: Jonathan Leivant *)
(* This file is part of LibHyps.

    Foobar is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Foobar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see <https://www.gnu.org/licenses/>. *)

(** This file defined three tacticals for iterating a tactic on sets
    of hypothesis.

    [onAllHyp tac] applies [tac H] for each H of the proof context
    (natural order: newer hyps first).

    [onAllHypRev tac] applies [tac H] for each H of the proof context
    (reverse order).

    [onNewHypsOf tac1 do tac] applies tac1 on the current goal, then
    applies tac on each "new" hypothesis generated by tac1. A
    hypothesis is "new" if its name was not present before tac1 was
    applied.

    In all these tacticals, a failure in applying tac to a hypothesis
    is ignored and does make the whole expression to fail. *)

(* Credit for the harvesting of hypothesis: Jonathan Leivant *)
Ltac harvest_hyps harvester := constr:(ltac:(harvester; constructor) : True).

Ltac revert_clearbody_all :=
  repeat lazymatch goal with H:_ |- _ => try clearbody H; revert H end.

Ltac all_hyps := harvest_hyps revert_clearbody_all.

Ltac next_hyp hs step last :=
  lazymatch hs with
  | (?hs' ?H) => step H hs'
  | _ => last
  end.

Ltac map_hyps tac hs :=
  idtac;
  let rec step H hs := next_hyp hs step idtac; tac H in
  next_hyp hs step idtac.

(* This performs the map from "top" to "bottom" (from older to younger hyps). *)
Ltac map_hyps_rev tac hs :=
  idtac;
  let rec step H hs := tac H ; next_hyp hs step idtac in
  next_hyp hs step idtac.

Ltac map_all_hyps tac := map_hyps tac all_hyps.
Ltac map_all_hyps_rev tac := map_hyps_rev tac all_hyps.

(* For less parenthesis: OnAllHyp tacA;tac2. *)
Tactic Notation (at level 3) "onAllHyps" tactic(Tac) := (map_all_hyps Tac).
Tactic Notation (at level 3) "onAllHypsRev" tactic(Tac) := (map_all_hyps_rev Tac).

Ltac tac_if_not_old tac old_hyps H :=
  match old_hyps with
  | context [H] => idtac (* old_hyps contains all old hyps in a product *)
  | _ => tac H + idtac (* never fail, this could be configurable *)
  end.


(* Applies tac to the goal and then aftertac to each new hypothesis of
   resulting subgoals older first *)
Ltac tac_new_hyps tac1 tac2 :=
  let hyps_before_tac := all_hyps in
  let tac2_if_new H := tac_if_not_old tac2 hyps_before_tac H in
  tac1 ;
  let hyps_after_tac := all_hyps in
  map_hyps tac2_if_new hyps_after_tac.

(* Same thing but newer first (better e.g. when tac2 is revert) *)
Ltac tac_new_hyps_rev tac1 tac2 :=
  let hyps_before_tac := all_hyps in
  let tac2_if_new H := tac_if_not_old tac2 hyps_before_tac H in
  tac1 ;
  let hyps_after_tac := all_hyps in
  map_hyps_rev tac2_if_new hyps_after_tac.

(* Tactic Notation (at level 3) "onNewHypsOf" tactic(Tac) "do" tactic3(Tac2) := (tac_new_hyps Tac Tac2). *)
(* Tactic Notation (at level 3) "onNewHypsOfRev" tactic(Tac) "do" tactic3(Tac2) := (tac_new_hyps_rev Tac Tac2). *)

(* infix syntax for  *)
Tactic Notation (at level 4) tactic4(tac1) ";;" tactic3(tac2) := (tac_new_hyps tac1 tac2).
Tactic Notation (at level 4) tactic4(tac1) ";!;" tactic3(tac2) := (tac_new_hyps_rev tac1 tac2).

